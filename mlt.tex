\documentclass{article}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{multicol}
\usepackage[utf8x]{inputenc}

% Metavars
\newcommand\term{t}
\newcommand\ty{\tau}
\newcommand\tyenv{\Gamma}
\newcommand\csenv{C}

% Constructions 

% Term
\newcommand\var{x}
\newcommand\app[2]{#1\,#2}
\newcommand\lam[2]{\lambda #1. #2}

% Value
\newcommand\val{v}

% Type
\newcommand\tyconst{\iota}
\newcommand\tyvar{\alpha}
\newcommand\tykind{*}
\newcommand\tyarrow[2]{#1 \rightarrow #2}

% Binding
\newcommand\binding[2]{(#1 : #2)}

% Typing environment
\newcommand\tyenvnil{\bullet}
\newcommand\tyenvcons[3]{#1; \binding{#2}{#3}}

% Jugements
\newcommand\tycheck[3]{#1 \vdash #2 : #3}
\newcommand\tyenvmem[2]{#1 \in #2}

% Keyword
\newcommand\kw[1]{\operatorname{#1}}

% Syntax
\newcommand\syn[1]{#1 ::=& \; }
\newcommand\synor{\\ |& \; }
\begin{document}

% Pattern
\newcommand\pator{\;|\;}

% Operation semantic
\newcommand\redto[2]{#1 \longrightarrow #2}

\section{Syntax}

\begin{multicols}{2}
\begin{align*}
  \syn{\term_1, \term_2} \var, y
  \synor      \term_1 \, \term_2
  \synor      \lambda \binding{\var}{\ty} . \term
  \synor      \Lambda \tyvar . \term
  \synor      \term \, \ty
  \synor      prim \, \vec{\term}
%  \synor      \kw{letrec} \vec{\var_i : \ty_i = \term_i} \kw{in} \term
  \synor      \kw{switch} \term \kw{in} \vec{b} : \ty
  \synor      \kw{unpack} \term_1 \kw{as} \var \kw{in} \term_2
%
  \\ \\
%
  \syn{b} n \rightarrow \term \; | \; b
  \synor  \_ \rightarrow \term
  \synor  \emptyset
%
  \\ \\
%
  \syn{\ty_1, \ty_2} \tyvar, \beta
  \synor  \ty_1 \rightarrow \ty_2
  \synor  \forall \tyvar. \ty
  \synor  F
  \synor  \{ \var \}_F
  \synor  \kw{Tag}_z \var
  \synor  \{ n: \vec{\ty} \}
  \\
  \syn{F} \epsilon \, \vec{\ty}
\end{align*}
   
\begin{align*}
  \syn{C} C \wedge C
  \synor  \ty_1 = \ty_2
  \synor  \kw{tag} \var \in S
  \synor  \top
%
  \\ \\
%
  \syn{S} \emptyset
  \synor  \{ k_1, \ldots, k_n \}
  \synor  \lnot \{ k_1, \ldots, k_n \}
%
  \\ \\
%
  \syn{\tyenv} .
  \synor \tyenv \binding{\alpha}{*}
  \synor \tyenv \binding{\var}{\ty}
%
  \\ \\
%
  \syn{prim} \kw{makeblock}_{n,\ty}
  \synor \kw{tagof}
  \synor \kw{field}_{n}
  \synor \kw{eq}_{z}
  \synor \kw{lt}_{z}
  \synor \kw{isint}
  \synor \kw{isout}_{[z1,z2]}
  \synor \kw{shift}_{z}
\end{align*}
\end{multicols}

\section{Règles de typage}

\begin{mathpar}

\infer{
  \tyenvmem{\binding\var\ty}\tyenv
}{
  \tycheck\tyenv\var\ty
}

\infer{
  \tycheck{\csenv, \tyenvcons\tyenv\var{\ty_1}}{\term}{\ty_2}
}{
  \tycheck{\csenv, \tyenv}{\lam{\binding\var{\ty_1}}{\term}}{\tyarrow{\ty_1}{\ty_2}}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term_1}{\tyarrow{\ty_1}{\ty_2}} \\
  \tycheck{\csenv, \tyenv}{\term_2}{\ty_1}
}{
  \tycheck{\csenv, \tyenv}{\term_1 \term_2}{\ty_2}
}

%\infer{
%  \forall i.\; \tycheck{\csenv, \tyenvcons{\tyenv}{\forall j.\, \var_j}{\ty_j}}{\term_i}{\ty_i} \\
%  \tycheck{\csenv, \tyenvcons{\tyenv}{\forall j.\, \var_j}{\ty_j}}{\term}{\ty}
%}{
%  \tycheck{\csenv, \tyenv}{\kw{letrec} (\var_i : \ty_i = \term_i) \kw{in} \term}{\ty}
%}

\\

\infer{
  \tycheck{\csenv, \tyenvcons{\tyenv}{\tyvar}{\tykind}}{\term}{\ty}
}{
  \tycheck{\csenv, \tyenv}{\Lambda \tyvar . \term }{\forall \tyvar.\, \ty}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\forall \tyvar.\, \ty_1}
}{
  \tycheck{\csenv, \tyenv}{\term \, \ty_2}{\ty_1 \{\tyvar \leftarrow \ty_2\}}
}

\\

\infer{
  x \notin \kw{dom}(\tyenv) \\ x \notin \kw{FV}(\ty) \\
  \tycheck{\csenv, \tyenv}{\term_1}{F} \\
  \tycheck{\csenv, \tyenvcons{\tyenv}
                             {\var}{ \{ \var \}_F }}
          {\term_2}{\ty}
}{
  \tycheck{\csenv, \tyenv}{\kw{unpack} \term_1 \kw{as} \var \kw{in} \term_2}{\ty} \\
}

\\

\infer{
  k \in dom(F) \\
  \tycheck{\csenv \wedge \kw{tag} \var \in \{ k \} \wedge F k, \tyenv}{\term}{\ty} \\
  \tycheck{\csenv \wedge \kw{tag} \var \in \lnot \{ k \}, x, F, \tyenv}{\vec{b}}{\ty}
}{
  \tycheck{\csenv, \tyenv, x, F}{k \rightarrow \term \;|\; \vec{b}}{\ty}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\ty}
}{
  \tycheck{\csenv, \tyenv, x, F}{\_ \rightarrow \term}{\ty}
}

\infer{
  %FIXME: from constraints, we deduce tag = empty%
  \csenv \Vdash dom(F) \cap \kw{tag} x = \emptyset
}{
  \tycheck{\csenv, \tyenv, x, F}{\emptyset}{\ty}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\{ \var \}_F} \\
  \tycheck{\csenv, \tyenv, \var, F}{\vec{b}}{\ty}
}{
  \tycheck{\csenv, \tyenv}{\kw{switch} \term \kw{in} \vec{b}}{\ty}
}

\end{mathpar}

\section{Type des primitives}
\begin{mathpar}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\{ \var \}_F}
}{
  \tycheck{\csenv, \tyenv}{\kw{tagof} \term}{\kw{Tag} \{ \var \}_F}
}


\infer{
  \tycheck{\csenv, \tyenv}{\term}{\{ k: \vec{\ty_n} \}}
}{
  \tycheck{\csenv, \tyenv}{\kw{field}_i \term}{\ty_i}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\{ k: \vec{\ty_n} \}}
}{
  \tycheck{\csenv, \tyenv}{\kw{field}_i \term}{\ty_i}
}

\infer{
  k \in dom(F) \\
  \tycheck{\forall i. \, \csenv, \tyenv}{\term_i}{F_{k,i}} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{makeblock}_{k,F} \vec{\term_n}}{F}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\kw{Tag}_z \var} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{shift}_k \term}{\kw{Tag}_{z+k} \var}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\kw{Tag} \var} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{isint} \term}{\kw{IsInt}(x,F)}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\kw{Tag}_z \var} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{eq}_k \term}{\operatorname{Eq}(k-z,x,F)}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\kw{Tag}_z \var} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{lt}_k \term}{\operatorname{Lt}(k-z,x,F)}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\kw{Tag}_z \var} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{isout}_{[z1,z2]} \term}{\operatorname{IsOut}(z1-z,z2-z,x,F)}
}

\end{mathpar}

\section{Constructeurs de types}

\begin{align*}
  \syn{\rho} k \rightarrow \vec{\ty} \,;\, \rho
  \synor \ldots
  \synor \emptyset
\end{align*}

Soit $\epsilon$ l'ensemble des noms des constructeurs de types. \\
On suppose l'existence d'une fonction 
$\delta : \epsilon \times \vec{\ty} \to \rho$.

\section{Sémantique des contraintes}

\section{Sémantique opérationnelle}

\begin{mathpar} \\

\redto{\app{(\lambda \binding{\var}{\ty} . \term)}{\val}}
      {\term\{ \var \leftarrow \val\}}
\\

\infer{
  \redto{\term_1}{\term'_1}
}{
  \redto{\app{\val}{\term_1}}{\app{\val}{\term'_1}}
}
\\

\infer{
  \redto{\term_1}{\term'_1}
}{
  \redto{\app{\term_1}{\term_2}}{\app{\term'_1}{\term_2}}
}
\\

\infer{
  \redto{\term_1}{\term'_1}
}{
  \redto{\kw{switch} \term_1 \kw{in} \vec{b}}{\kw{switch} \term'_1 \kw{in} \vec{b}}
}
\\

\infer{
  \redto{\term_1}{\term'_1}
}{
  \redto{\kw{switch} \term_1 \kw{in} \vec{b}}{\kw{switch} \term'_1 \kw{in} \vec{b}}
}
\\

\infer{
  \kw{tagof} \val = k
}{
  \redto{\kw{switch} \val \kw{in} k \rightarrow \term \pator \vec{b}}
        {\term}
}
\\

\infer{
  \kw{tagof} \val \neq k
}{
  \redto{\kw{switch} \val \kw{in} k \rightarrow \term \pator \vec{b}}
        {\kw{switch} \val \kw{in} \vec{b}}
}
\\

\redto{\kw{switch} \val \kw{in} \_ \rightarrow \term}
      {\term}
\\

\infer{
  \redto{\term_1}{\term'_1}
}{
  \redto{\kw{unpack} \term_1 \kw{as} \var \kw{in} \term_2}
        {\kw{unpack} \term'_1 \kw{as} \var \kw{in} \term_2}
}
\\

\redto{\kw{unpack} \val \kw{as} \var \kw{in} \term_2}
      {\term_2\{\var \leftarrow \val\}}
\\

% Erase types
\redto{\Lambda \tyvar . \term}{\term}

\redto{\term \, \ty}{\term}
\\

\infer{
  \redto{\vec{\term}}{\vec{\term'}}
}{
  \redto{\app{prim}{\vec{\term}}}{\app{prim}{\vec{\term'}}}
}
\\

\end{mathpar}

\section{Réduction des primitives}

\begin{mathpar} \\

\redto{\kw{makeblock}_{k,\ty} \vec{v}}{\{k: \vec{v}\}} \\


\redto{\kw{field}_i \{k: \vec{v}\}}{v_i} \\


\redto{\kw{shift}_z k}{z + k} \\


\redto{\kw{tagof} k}{k}

\redto{\kw{tagof} \{k: \vec{v}\}}{k} \\


\infer{ [k] = z }
      { \redto{\kw{eq}_z k}{1} }

\infer{ [k] \neq z }
      { \redto{\kw{eq}_z k}{0} }
\\


\infer{ [k] \le z }
      { \redto{\kw{lt}_z k}{1} }

\infer{ [k] \nless z }
      { \redto{\kw{lt}_z k}{0} }
\\


\redto{\kw{isint} k}{1}

\redto{\kw{isint} \{k: \vec{v}\}}{0}
\\

\infer{ [k] \in [k_1,k_2] }
      { \redto{\kw{isout}_{[k_1,k_2]} k}{0} }

\infer{ [k] \notin [k_1,k_2] }
      { \redto{\kw{isout}_{[k_1,k_2]} k}{1} }
\\

\end{mathpar}

\section{Formation des contextes}

\begin{mathpar}
\infer{ }{ \vdash . }

\infer{
  \vdash \tyenv \\
  \tyenv \vdash \ty
}{
  \vdash \tyenvcons\tyenv{\var}{\ty}
}

\infer{
  \vdash \tyenv \\
  \tyenv \vdash F
}{
  \vdash \tyenvcons\tyenv{\var}{\{ \var \}_F}
}
\end{mathpar}

\end{document}
