\documentclass[12pt]{report}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{multicol}
\usepackage[utf8x]{inputenc}
\usepackage[french]{babel}

% Metavars
\newcommand\term{t}
\newcommand\ty{\tau}
\newcommand\tyenv{\Gamma}
\newcommand\csenv{C}

\newcommand\todo[1]{TODO[#1]}
% Constructions 

% Term
\newcommand\var{x}
\newcommand\app[2]{#1\,#2}
\newcommand\lam[2]{\lambda #1. #2}

% Value
\newcommand\val{v}

% Type
\newcommand\tyconst{\iota}
\newcommand\tyvar{\alpha}
\newcommand\tykind{*}
\newcommand\tyarrow[2]{#1 \rightarrow #2}

% Binding
\newcommand\binding[2]{(#1 : #2)}

% Typing environment
\newcommand\tyenvnil{\bullet}
\newcommand\tyenvcons[3]{#1; \binding{#2}{#3}}

% Jugements
\newcommand\tycheck[3]{#1 \vdash #2 : #3}
\newcommand\tyenvmem[2]{#1 \in #2}

% Keyword
\newcommand\kw[1]{\operatorname{#1}}

% Syntax
\newcommand\syn[1]{#1 ::=& \; }
\newcommand\synor{\\ |& \; }

% Pattern
\newcommand\pator{\;|\;}

% Operation semantic
\newcommand\redto[2]{#1 \longrightarrow #2}

\title{Typage d'un lambda-calcul avec une construction de branchements}
\author{Frédéric Bour, avec l'encadrement de Yann Régis-Gianas}

\begin{document}

\maketitle

\chapter{Motivations}

Ce TRE a débuté par une évaluation de la faisabilité d'une analyse statique du
flot des exceptions pour OCaml 4.00. 

Les systèmes d'exceptions permettent au programmeur de manipuler le contrôle de
flot beaucoup plus librement qu'avec un traditionnel appel de fonction
retournant une valeur. Malheureusement, il devient alors difficile de connaître
les différents flots d'exécutions possibles car ceux-ci ne correspondent plus
strictement à la structure du code source -- on parle de contrôle de flot
non-local.

Bien qu'OCaml soit reconnu pour la sûreté des programmes écrits avec, il faut
souvent se priver d'exceptions pour garantir celle-ci.

L'analyse statique que nous souhaitions effectuer vise à vérifier de manière
mécanique l'absence d'exceptions ou bien l'exhaustivité de leur traitement dans
un code source.

Ce travail reprenait les résultats de la thèse de François Pessaux \todo{ref
these} qui avait abouti à un prototype permettant ce type d'analyse pour OCaml
3.00.  Les résultats étaient très encourageants au point de présenter un
intérêt immédiat pour des applications industrielles (\todo{ref ocamlpro ?}).

Malheureusement, ce prototype n'a pas été porté vers les versions suivantes
d'OCaml et nous sommes arrivé à la conclusion que ce travail était trop
conséquent pour s'inscrire dans le cadre d'un TRE.  De plus, si l'approche
abordée dans la thèse permet une analyse fine, l'implantation est difficile à
maintenir car celle-ci s'appuie sur la syntaxe abstraite d'OCaml et implique de
développer en parallèle un typeur spécialisé.

Notre travail de recherche s'est alors orienté vers le langage intermédiaire du
compilateur OCaml. 

\section{\emph{Lambda}, le langage intermédiaire}

Cibler \emph{Lambda} apporte de nombreux avantages, notamment :
\begin{description}
  \item[Indépendance vis-à-vis du \emph{front-end}]. Si le langage de surface
    OCaml est régulièrement étendu, \emph{Lambda} est très stable et n'a pas
    connu de changements majeurs depuis l'introduction du système objet il y a
    plus de 10 ans. C'est une cible pérenne.(\todo{ref OO})
  \item[Langage minimaliste].
    Les nombreuses constructions de surface sont réduites à un petit ensemble.
    \todo{facteur 10 entre TypedTree et lambda}.
    L'analyse peut ainsi se concentrer directement sur le cœur du langage et
    garder une taille modeste. Le travail de maintenance est moindre.
\end{description}

Cependant, ce langage n'est pas typé. Dans la chaîne de traitement du
compilateur, les types sont vérifiées pour le langage source par le typeur puis
effacé. Tout le reste du traitement s'effectue sur une version non-typée du
programme sémantiquement équivalente. Ce choix est justifié compte par
l'omniprésence du polymorphisme paramétrique dans ce langage et de la
représentation très régulière des valeurs à l'exécution.

Le polymorphisme paramétrique offre la garantie qu'un programme bien typé est
équivalent après effacement des types \todo{ref didier rémy ?}, et la
représentation des valeurs permet au runtime de travailler correctement sans
information de types -- cela concerne par exemple la convention d'appel des
fonctions ou le passage du glâneur de cellule.

\todo{figure : pipeline ocaml}.

Ce choix restreint les traitements possibles dans la suite de la compilation.
Le compilateur natif tente par exemple de réinférer des types dans le cadre
de certaines optimisations, mais il ne s'agit que d'approximation conservative.  
Dans notre cas analyser le flot devient beaucoup plus compliqué -- un travail
absurde quand on sait que les informations nécessaires pour guider
correctement cette analyse viennent d'être effacées dans la chaîne de
compilation.

Avant d'avoir un outil d'analyse respectant cette architecture, il fallait donc
concevoir une version de \emph{lambda} préservant les types.

\section{Vers une version \emph{typée} de \emph{Lambda}}

Le langage \emph{lambda} est un lambda-calcul proposant des fonctions de très
bas-niveau.

Lambda-calcul désigne, dans le cadre de la compilation, une famille de
langage de programmation fonctionnelle reposant autour d'un unique mécanisme
d'abstraction.
Cela rend sa définition simplissime, le noyau syntaxique tient en trois règles.
Mais derrière celles-ci se cache une très grande expressivité :
c'est un langage turing-complet et d'un suffisamment haut-niveau pour permettre
un encodage léger des constructions classiques des langages de programmation.
(\todo{cite appel, steele, ?}).

Un lambda-calcul est ainsi un choix naturel pour un langage intermédiaire. La
variante d'OCaml ajoute principalement des primitives d'accès mémoires et de
branchements, des extensions de bas-niveau.

Une autre implantation majeure d'un langage de programmation fonctionnelle
proche de ML, \todo{ref GHC}, a fait un choix très différent dans la conception
de son langage intermédiaire nommé \emph{Core}.
Ce dernier est typé et n'offre pas de telles primitives; les accès mémoires
sont masqués derrière une forme simplifiée de \emph{filtrage de motifs}.
\todo{cite System FC} Ce design influencera nos choix par la suite.

\section{Le typage des constructions de bas-niveau}

Les systèmes de types d'Ocaml et d'Haskell présentent de nombreuses
similarités. La réussite de \emph{Core} nous a conforté dans la faisabilité
d'un traitement similaire pour OCaml.

Cependant dans le soucis d'être le moins intrusif possible dans le compilateur
OCaml actuel, il était nécessaire d'étendre le langage \emph{lambda} et non de
le remplacer.

Pour mener à terme cet objectif, les étapes suivantes se profilaient :
\begin{itemize}
  \item concevoir un système de type s'inspirant de System $F_c$ et composant
    avec les contraintes imposées par \emph{lambda},
  \item établir encodage des constructions d'Ocaml (types algébriques, modules,
    GADTs, variants polymorphes) dans ce système afin de s'assurer que toutes
    sont capturées,
  \item étendre \emph{lambda} et proposer un schéma de compilation vers ce
    nouveau langage intermédiaire.
\end{itemize}

Ceci constitue un travail de grande ampleur. Dans ce rapport nous adressons le
le point précis de typer les contraintes imposées par \emph{lambda};
un branchement et des accès mémoires beaucoup plus libre que ce que permet le
\emph{filtrage de motif} traditionnel.

\chapter{Solutions étudiées}

Tout n'est pas nécessaire, points principaux :

\section{Échec du typage structurel}

\subsection{Succès du typage nominal}

- encodage des exceptions
- encodage des GADTs
- encodage des variants
  - traduction du langage ML
    shift, extraction de tags, …

\chapter{Langage proposé}

\section{Syntaxe}

\begin{multicols}{2}
\begin{align*}
  \syn{\term_1, \term_2} \var, y
  \synor      \term_1 \, \term_2
  \synor      \lambda \binding{\var}{\ty} . \term
  \synor      \Lambda \tyvar . \term
  \synor      \term \, \ty
  \synor      prim \, \vec{\term}
%  \synor      \kw{letrec} \vec{\var_i : \ty_i = \term_i} \kw{in} \term
  \synor      \kw{switch} \term \kw{in} \vec{b} : \ty
  \synor      \kw{unpack} \term_1 \kw{as} \var \kw{in} \term_2
%
  \\ \\
%
  \syn{b} n \rightarrow \term \; | \; b
  \synor  \_ \rightarrow \term
  \synor  \emptyset
%
  \\ \\
%
  \syn{\ty_1, \ty_2} \tyvar, \beta
  \synor  \ty_1 \rightarrow \ty_2
  \synor  \forall \tyvar. \ty
  \synor  F
  \synor  \{ \var \}_F
  \synor  \kw{Tag}_z \var
  \synor  \{ n: \vec{\ty} \}
  \\
  \syn{F} \epsilon \, \vec{\ty}
\end{align*}
   
\begin{align*}
  \syn{C} C \wedge C
  \synor  \ty_1 = \ty_2
  \synor  \kw{tag} \var \in S
  \synor  \top
%
  \\ \\
%
  \syn{S} \emptyset
  \synor  \{ k_1, \ldots, k_n \}
  \synor  \lnot \{ k_1, \ldots, k_n \}
%
  \\ \\
%
  \syn{\tyenv} .
  \synor \tyenv \binding{\alpha}{*}
  \synor \tyenv \binding{\var}{\ty}
%
  \\ \\
%
  \syn{prim} \kw{makeblock}_{n,\ty}
  \synor \kw{tagof}
  \synor \kw{field}_{n}
  \synor \kw{eq}_{z}
  \synor \kw{lt}_{z}
  \synor \kw{isint}
  \synor \kw{isout}_{[z1,z2]}
  \synor \kw{shift}_{z}
\end{align*}
\end{multicols}

\section{Règles de typage}

\begin{mathpar}

\infer{
  \tyenvmem{\binding\var\ty}\tyenv
}{
  \tycheck\tyenv\var\ty
}

\infer{
  \tycheck{\csenv, \tyenvcons\tyenv\var{\ty_1}}{\term}{\ty_2}
}{
  \tycheck{\csenv, \tyenv}{\lam{\binding\var{\ty_1}}{\term}}{\tyarrow{\ty_1}{\ty_2}}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term_1}{\tyarrow{\ty_1}{\ty_2}} \\
  \tycheck{\csenv, \tyenv}{\term_2}{\ty_1}
}{
  \tycheck{\csenv, \tyenv}{\term_1 \term_2}{\ty_2}
}

%\infer{
%  \forall i.\; \tycheck{\csenv, \tyenvcons{\tyenv}{\forall j.\, \var_j}{\ty_j}}{\term_i}{\ty_i} \\
%  \tycheck{\csenv, \tyenvcons{\tyenv}{\forall j.\, \var_j}{\ty_j}}{\term}{\ty}
%}{
%  \tycheck{\csenv, \tyenv}{\kw{letrec} (\var_i : \ty_i = \term_i) \kw{in} \term}{\ty}
%}

\\

\infer{
  \tycheck{\csenv, \tyenvcons{\tyenv}{\tyvar}{\tykind}}{\term}{\ty}
}{
  \tycheck{\csenv, \tyenv}{\Lambda \tyvar . \term }{\forall \tyvar.\, \ty}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\forall \tyvar.\, \ty_1}
}{
  \tycheck{\csenv, \tyenv}{\term \, \ty_2}{\ty_1 \{\tyvar \leftarrow \ty_2\}}
}

\\

\infer{
  x \notin \kw{dom}(\tyenv) \\ x \notin \kw{FV}(\ty) \\
  \tycheck{\csenv, \tyenv}{\term_1}{F} \\
  \tycheck{\csenv, \tyenvcons{\tyenv}
                             {\var}{ \{ \var \}_F }}
          {\term_2}{\ty}
}{
  \tycheck{\csenv, \tyenv}{\kw{unpack} \term_1 \kw{as} \var \kw{in} \term_2}{\ty} \\
}

\\

\infer{
  k \in dom(F) \\
  \tycheck{\csenv \wedge \kw{tag} \var \in \{ k \} \wedge F k, \tyenv}{\term}{\ty} \\
  \tycheck{\csenv \wedge \kw{tag} \var \in \lnot \{ k \}, x, F, \tyenv}{\vec{b}}{\ty}
}{
  \tycheck{\csenv, \tyenv, x, F}{k \rightarrow \term \;|\; \vec{b}}{\ty}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\ty}
}{
  \tycheck{\csenv, \tyenv, x, F}{\_ \rightarrow \term}{\ty}
}

\infer{
  %FIXME: from constraints, we deduce tag = empty%
  \csenv \Vdash dom(F) \cap \kw{tag} x = \emptyset
}{
  \tycheck{\csenv, \tyenv, x, F}{\emptyset}{\ty}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\{ \var \}_F} \\
  \tycheck{\csenv, \tyenv, \var, F}{\vec{b}}{\ty}
}{
  \tycheck{\csenv, \tyenv}{\kw{switch} \term \kw{in} \vec{b}}{\ty}
}

\end{mathpar}

\section{Type des primitives}
\begin{mathpar}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\{ \var \}_F}
}{
  \tycheck{\csenv, \tyenv}{\kw{tagof} \term}{\kw{Tag} \{ \var \}_F}
}


\infer{
  \tycheck{\csenv, \tyenv}{\term}{\{ k: \vec{\ty_n} \}}
}{
  \tycheck{\csenv, \tyenv}{\kw{field}_i \term}{\ty_i}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\{ k: \vec{\ty_n} \}}
}{
  \tycheck{\csenv, \tyenv}{\kw{field}_i \term}{\ty_i}
}

\infer{
  k \in dom(F) \\
  \tycheck{\forall i. \, \csenv, \tyenv}{\term_i}{F_{k,i}} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{makeblock}_{k,F} \vec{\term_n}}{F}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\kw{Tag}_z \var} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{shift}_k \term}{\kw{Tag}_{z+k} \var}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\kw{Tag} \var} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{isint} \term}{\kw{IsInt}(x,F)}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\kw{Tag}_z \var} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{eq}_k \term}{\operatorname{Eq}(k-z,x,F)}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\kw{Tag}_z \var} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{lt}_k \term}{\operatorname{Lt}(k-z,x,F)}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\kw{Tag}_z \var} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{isout}_{[z1,z2]} \term}{\operatorname{IsOut}(z1-z,z2-z,x,F)}
}

\end{mathpar}

\section{Constructeurs de types}

\begin{align*}
  \syn{\rho} k \rightarrow \vec{\ty} \,;\, \rho
  \synor \ldots
  \synor \emptyset
\end{align*}

Soit $\epsilon$ l'ensemble des noms des constructeurs de types. \\
On suppose l'existence d'une fonction 
$\delta : \epsilon \times \vec{\ty} \to \rho$.

\section{Sémantique des contraintes}

\section{Sémantique opérationnelle}

\begin{mathpar} \\

\redto{\app{(\lambda \binding{\var}{\ty} . \term)}{\val}}
      {\term\{ \var \leftarrow \val\}}
\\

\infer{
  \redto{\term_1}{\term'_1}
}{
  \redto{\app{\val}{\term_1}}{\app{\val}{\term'_1}}
}
\\

\infer{
  \redto{\term_1}{\term'_1}
}{
  \redto{\app{\term_1}{\term_2}}{\app{\term'_1}{\term_2}}
}
\\

\infer{
  \redto{\term_1}{\term'_1}
}{
  \redto{\kw{switch} \term_1 \kw{in} \vec{b}}{\kw{switch} \term'_1 \kw{in} \vec{b}}
}
\\

\infer{
  \redto{\term_1}{\term'_1}
}{
  \redto{\kw{switch} \term_1 \kw{in} \vec{b}}{\kw{switch} \term'_1 \kw{in} \vec{b}}
}
\\

\infer{
  \kw{tagof} \val = k
}{
  \redto{\kw{switch} \val \kw{in} k \rightarrow \term \pator \vec{b}}
        {\term}
}
\\

\infer{
  \kw{tagof} \val \neq k
}{
  \redto{\kw{switch} \val \kw{in} k \rightarrow \term \pator \vec{b}}
        {\kw{switch} \val \kw{in} \vec{b}}
}
\\

\redto{\kw{switch} \val \kw{in} \_ \rightarrow \term}
      {\term}
\\

\infer{
  \redto{\term_1}{\term'_1}
}{
  \redto{\kw{unpack} \term_1 \kw{as} \var \kw{in} \term_2}
        {\kw{unpack} \term'_1 \kw{as} \var \kw{in} \term_2}
}
\\

\redto{\kw{unpack} \val \kw{as} \var \kw{in} \term_2}
      {\term_2\{\var \leftarrow \val\}}
\\

% Erase types
\redto{\Lambda \tyvar . \term}{\term}

\redto{\term \, \ty}{\term}
\\

\infer{
  \redto{\vec{\term}}{\vec{\term'}}
}{
  \redto{\app{prim}{\vec{\term}}}{\app{prim}{\vec{\term'}}}
}
\\

\end{mathpar}

\section{Réduction des primitives}

\begin{mathpar} \\

\redto{\kw{makeblock}_{k,\ty} \vec{v}}{\{k: \vec{v}\}} \\


\redto{\kw{field}_i \{k: \vec{v}\}}{v_i} \\


\redto{\kw{shift}_z k}{z + k} \\


\redto{\kw{tagof} k}{k}

\redto{\kw{tagof} \{k: \vec{v}\}}{k} \\


\infer{ [k] = z }
      { \redto{\kw{eq}_z k}{1} }

\infer{ [k] \neq z }
      { \redto{\kw{eq}_z k}{0} }
\\


\infer{ [k] \le z }
      { \redto{\kw{lt}_z k}{1} }

\infer{ [k] \nless z }
      { \redto{\kw{lt}_z k}{0} }
\\


\redto{\kw{isint} k}{1}

\redto{\kw{isint} \{k: \vec{v}\}}{0}
\\

\infer{ [k] \in [k_1,k_2] }
      { \redto{\kw{isout}_{[k_1,k_2]} k}{0} }

\infer{ [k] \notin [k_1,k_2] }
      { \redto{\kw{isout}_{[k_1,k_2]} k}{1} }
\\

\end{mathpar}

\section{Formation des contextes}

\begin{mathpar}
\infer{ }{ \vdash . }

\infer{
  \vdash \tyenv \\
  \tyenv \vdash \ty
}{
  \vdash \tyenvcons\tyenv{\var}{\ty}
}

\infer{
  \vdash \tyenv \\
  \tyenv \vdash F
}{
  \vdash \tyenvcons\tyenv{\var}{\{ \var \}_F}
}
\end{mathpar}

\end{document}
