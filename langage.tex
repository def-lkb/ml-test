% Metavars
\newcommand\term{t}
\newcommand\ty{\tau}
\newcommand\tyenv{\Gamma}
\newcommand\csenv{C}

% Term
\newcommand\var{x}
\newcommand\app[2]{#1\,#2}
\newcommand\lam[2]{\lambda #1. #2}

% Value
\newcommand\val{v}

% Type
\newcommand\tyconst{\iota}
\newcommand\tyvar{\alpha}
\newcommand\tykind{*}
\newcommand\tyarrow[2]{#1 \rightarrow #2}

% Binding
\newcommand\binding[2]{(#1 : #2)}

% Typing environment
\newcommand\tyenvnil{\bullet}
\newcommand\tyenvcons[3]{#1; \binding{#2}{#3}}

% Jugements
\newcommand\tycheck[3]{#1 \vdash #2 : #3}
\newcommand\tyenvmem[2]{#1 \in #2}

% Keyword
\newcommand\kw[1]{\operatorname{#1}}

% Syntax
\newcommand\syn[1]{#1 ::=& \; }
\newcommand\synor{\\ |& \; }
\newcommand\syndesc[1]{& \text{#1}}

% Pattern
\newcommand\pator{\;|\;}

% Operation semantic
\newcommand\redto[2]{#1 \longrightarrow #2}

% Naming rules
\newcommand\rname[1]{\;\;\textsc{{\small(#1)}}}
\newcommand\rref[1]{\textsc{\small#1}}
\newcommand\rcase[1]{\paragraph{Cas \rref{#1}:}}

\newtheorem{thm}{Théorème}
\newtheorem{lemma}{Lemme}

\section{Langage proposé}

\subsection{Syntaxe}

\begin{figure}
\begin{align*}
  \syn{\term_1, \term_2} \var, y 
    \syndesc{variable}
  \synor      \term_1 \, \term_2
    \syndesc{application}
  \synor      \lambda \binding{\var}{\ty} . \term
    \syndesc{abstraction}
  \synor      \Lambda \tyvar . \term
    \syndesc{abstraction de type}
  \synor      \term \, \ty
    \syndesc{application de type}
  \synor      prim \, \vec{\term}
    \syndesc{application de primitives}
  \synor      \kw{switch} \term \kw{in} \vec{b} : \ty
    \syndesc{aiguillage}
  \synor      \kw{unpack} \term_1 \kw{as} \var \kw{in} \term_2
    \syndesc{ouverture d'un bloc}
\end{align*}
\caption{Syntaxe des termes}
\end{figure}

\begin{figure}
\begin{align*}
  \syn{b} n \rightarrow \term \; | \; b
    \syndesc{cas constant}
  \synor  \_ \rightarrow \term
    \syndesc{cas par défaut}
  \synor  \emptyset
    \syndesc{absence de cas par défaut}
\end{align*}
\caption{Clauses de branchement}
\end{figure}

\begin{figure}
\begin{align*}
  \syn{\ty_1, \ty_2} \tyvar, \beta
    \syndesc{variables de type}
  \synor  \ty_1 \rightarrow \ty_2
    \syndesc{type flèche}
  \synor  \forall \tyvar. \ty
    \syndesc{quantification universelle}
  \synor  D
    \syndesc{type construit}
  \synor  \{ \var \}_D
    \syndesc{type \emph{singleton}}
  \synor  \kw{Tag}_z \var
    \syndesc{type du \emph{tag} d'un \emph{singleton}}
  \synor  \{ n: \vec{\ty} \}
    \syndesc{type d'un bloc immédiat}
  \\
  \syn{D} \epsilon \, \vec{\ty}
    \syndesc{constructeur paramétré}
\end{align*}
\caption{Syntaxe des types}
\end{figure}

\begin{figure}
\begin{align*}
  \syn{C} C \wedge C
    \syndesc{conjonction}
  \synor  \ty_1 = \ty_2
    \syndesc{égalité de types}
  \synor  \kw{tag} \var \in S
    \syndesc{restriction d'un \emph{tag}}
  \synor  \top
    \syndesc{Vrai}
  \synor  \bot
    \syndesc{Faux}
\end{align*}
\caption{Syntaxe des contraintes}
\end{figure}

\begin{figure}
\begin{align*}
  \syn{S} \emptyset
    \syndesc{ensemble vide}
  \synor  \{ k_1, \ldots, k_n \}
    \syndesc{ensemble fini}
  \synor  \lnot \{ k_1, \ldots, k_n \}
    \syndesc{complémentaire}
\end{align*}
\caption{Ensemble de \emph{tags}}
\end{figure}

\begin{figure}
\begin{align*}
  \syn{\tyenv} .
    \syndesc{contexte vide}
  \synor \tyenvcons\tyenv{\var}{\ty}
    \syndesc{liaison de terme}
  \synor \tyenvcons\tyenv{\alpha}{*}
    \syndesc{liaison de type}
\end{align*}
\caption{Syntaxe des contextes}
\end{figure}

\begin{figure}
\begin{align*}
  \syn{prim} \kw{makeblock}_{n,D}
    \syndesc{allocation d'un bloc}
  \synor \kw{tagof}
    \syndesc{extraction d'un \emph{tag}}
  \synor \kw{field}_{n}
    \syndesc{projection d'un champ}
  \synor \kw{eq}_{z}
    \syndesc{égalité}
  \synor \kw{lt}_{z}
    \syndesc{infériorité}
  \synor \kw{isint}
    \syndesc{test d'entier}
  \synor \kw{isout}_{[z1,z2]}
    \syndesc{test d'intervalle}
  \synor \kw{shift}_{z}
    \syndesc{décalage constant}
\end{align*}
\caption{Primitives du langage}
\end{figure}

\pagebreak

\subsection{Système de type}

\subsubsection{Formation des contextes}

\begin{mathpar}
\infer{ }{ \vdash . }

\infer{
  \vdash \tyenv \\
  \tyenv \vdash \ty
}{
  \vdash \tyenvcons\tyenv{\var}{\ty}
}

\infer{
  \vdash \tyenv \\
  \tyenv \vdash D
}{
  \vdash \tyenvcons\tyenv{\var}{\{ \var \}_D}
}
\end{mathpar}

\subsubsection{Règles de typage}

\begin{mathpar}
%
\infer{
  \vdash \tyenv \\
  \tyenvmem{\binding\var\ty}\tyenv
}{
  \tycheck\tyenv\var\ty
}\rname{T-Var}

\infer{
  \tycheck{\csenv, \tyenvcons\tyenv\var{\ty_1}}{\term}{\ty_2}
}{
  \tycheck{\csenv, \tyenv}{\lam{\binding\var{\ty_1}}{\term}}{\tyarrow{\ty_1}{\ty_2}}
}\rname{T-Abs}

\infer{
  \tycheck{\csenv, \tyenv}{\term_1}{\tyarrow{\ty_1}{\ty_2}} \\
  \tycheck{\csenv, \tyenv}{\term_2}{\ty_1}
}{
  \tycheck{\csenv, \tyenv}{\term_1 \term_2}{\ty_2}
}\rname{T-App}
\\
%
\infer{
  \tycheck{\csenv, \tyenvcons{\tyenv}{\tyvar}{\tykind}}{\term}{\ty}
}{
  \tycheck{\csenv, \tyenv}{\Lambda \tyvar . \term }{\forall \tyvar.\, \ty}
}\rname{T-TApp}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\forall \tyvar.\, \ty_1}
}{
  \tycheck{\csenv, \tyenv}{\term \, \ty_2}{\ty_1 \{\tyvar \leftarrow \ty_2\}}
}\rname{T-TAbs}
\\
%
\infer{
  x \notin \kw{dom}(\tyenv) \\ x \notin \kw{FV}(\ty) \\
  \tycheck{\csenv, \tyenv}{\term_1}{D} \\
  \tycheck{\csenv, \tyenvcons{\tyenv}
                             {\var}{ \{ \var \}_D }}
          {\term_2}{\ty}
}{
  \tycheck{\csenv, \tyenv}{\kw{unpack} \term_1 \kw{as} \var \kw{in} \term_2}{\ty} \\
}\rname{T-Unpack}
\end{mathpar}
%
\begin{mathpar}
%
\infer{
  k \in dom(D) \\
  \tycheck{\csenv \wedge \kw{tag} \var \in \{ k \} \wedge D k, \tyenv}{\term}{\ty} \\
  \tycheck{\csenv \wedge \kw{tag} \var \in \lnot \{ k \}, x, D, \tyenv}{\vec{b}}{\ty}
}{
  \tycheck{\csenv, \tyenv, x, D}{k \rightarrow \term \;|\; \vec{b}}{\ty}
}\rname{T-DepPatTag}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\ty}
}{
  \tycheck{\csenv, \tyenv, x, D}{\_ \rightarrow \term}{\ty}
}\rname{T-DepPatAny}

\infer{
  \csenv \Vdash dom(D) \cap \kw{tag} x = \emptyset
}{
  \tycheck{\csenv, \tyenv, x, D}{\emptyset}{\ty}
}\rname{T-DepPatEmpty}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\{ \var \}_D} \\
  \tycheck{\csenv, \tyenv, \var, D}{\vec{b}}{\ty}
}{
  \tycheck{\csenv, \tyenv}{\kw{switch} \term \kw{in} \vec{b}}{\ty}
}\rname{T-DepSwitch}
%
\end{mathpar}
%
\begin{mathpar}
%
\infer{
  \tycheck{\csenv, \tyenv}{\term}{\ty} \\
  \tycheck{\csenv, \tyenv, \{k_1 \ldots k_n\}}{\vec{b}}{\ty}
}{
  \tycheck{\csenv, \tyenv, \{k_0 \ldots k_n\}}{k_0 \rightarrow \term \;|\; \vec{b}}{\ty}
}\rname{T-PatTag}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\ty}
}{
  \tycheck{\csenv, \tyenv, \{k_0 \ldots k_n\}}{\_ \rightarrow \term}{\ty}
}\rname{T-PatAny}

\infer{
}{
  \tycheck{\csenv, \tyenv, \emptyset}{\emptyset}{\ty}
}\rname{T-PatEmpty}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\{ k_0 \ldots k_n \}} \\
  \tycheck{\csenv, \tyenv, \{ k_0 \ldots k_n \}}{\vec{b}}{\ty}
}{
  \tycheck{\csenv, \tyenv}{\kw{switch} \term \kw{in} \vec{b}}{\ty}
}\rname{T-Switch}
%
\end{mathpar}

\subsubsection{Type des primitives}

\begin{mathpar}
%
\infer{
  \tycheck{\csenv, \tyenv}{\term}{\{ \var \}_D}
}{
  \tycheck{\csenv, \tyenv}{\kw{tagof} \term}{\kw{Tag} \{ \var \}_D}
}\rname{T-tagof}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\{ k: \vec{\ty_n} \}}
}{
  \tycheck{\csenv, \tyenv}{\kw{field}_i \term}{\ty_i}
}\rname{T-field-imm}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\{ \var \}_D} \\
  \csenv, \tyenv \Vdash \kw{tagof} \var \in \{ k \} \\
  D(k) = \vec{\ty_n}
}{
  \tycheck{\csenv, \tyenv}{\kw{field}_i \term}{\ty_i}
}\rname{T-field}

\infer{
  k \in dom(D) \\
  \tycheck{\forall i. \, \csenv, \tyenv}{\term_i}{D_{k,i}} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{makeblock}_{k,D} \vec{\term_n}}{D}
}\rname{T-makeblock}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\kw{Tag}_z \var} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{shift}_k \term}{\kw{Tag}_{z+k} \var}
}\rname{T-shift}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\kw{Tag} \var} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{isint} \term}{\kw{IsInt}(x,D)}
}\rname{T-isint}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\kw{Tag}_z \var} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{eq}_k \term}{\operatorname{Eq}(k-z,x,D)}
}\rname{T-eq}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\kw{Tag}_z \var} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{lt}_k \term}{\operatorname{Lt}(k-z,x,D)}
}\rname{T-lt}

\infer{
  \tycheck{\csenv, \tyenv}{\term}{\kw{Tag}_z \var} \\
}{
  \tycheck{\csenv, \tyenv}{\kw{isout}_{[z1,z2]} \term}{\operatorname{IsOut}(z1-z,z2-z,x,D)}
}\rname{T-isout}

\end{mathpar}

\subsubsection{Constructeurs de types}

\begin{align*}
  \syn{\rho} k \rightarrow C, \vec{\ty} \,;\, \rho
  \synor \ldots
  \synor \emptyset
\end{align*}

Soit $\epsilon$ l'ensemble des noms des constructeurs de types. \\
On suppose l'existence d'une fonction 
$\delta : \epsilon \times \vec{\ty} \to \rho$.

\todo{Meta constructeurs : IsInt, IsOut, Lt, Eq}
%TODO \subsection{Sémantique des contraintes}

\subsection{Sémantique opérationnelle}

\begin{mathpar}
%
\infer{}{
  \redto{\app{(\lambda \binding{\var}{\ty} . \term)}{\val}}
        {\term\{ \var \leftarrow \val\}}
}\rname{R-App}
\\

\infer{
  \redto{\term_1}{\term'_1}
}{
  \redto{\app{\val}{\term_1}}{\app{\val}{\term'_1}}
}\rname{R-App-1}

\infer{
  \redto{\term_1}{\term'_1}
}{
  \redto{\app{\term_1}{\term_2}}{\app{\term'_1}{\term_2}}
}\rname{R-App-2}
\\

\infer{
  \redto{\term}{\term'}
}{
  \redto{\term \, \ty}{\term' \, \ty}
}\rname{R-TApp-1}

\infer{}{
\redto{(\Lambda \tyvar . \term) \ty}{\term \{ \tyvar \leftarrow \ty \}}
}\rname{R-TApp}
%
\end{mathpar}
%
\begin{mathpar}
%
\infer{
  \redto{\term_1}{\term'_1}
}{
  \redto{\kw{switch} \term_1 \kw{in} \vec{b}}{\kw{switch} \term'_1 \kw{in} \vec{b}}
}\rname{R-Switch-1}

\infer{}{
  \redto{\kw{switch} \val \kw{in} \_ \rightarrow \term}
        {\term}
}\rname{R-PatAny}
\\
%
\infer{
  \kw{tagof} \val = k
}{
  \redto{\kw{switch} \val \kw{in} k \rightarrow \term \pator \vec{b}}
        {\term}
}\rname{R-PatMatch}

\infer{
  \kw{tagof} \val \neq k
}{
  \redto{\kw{switch} \val \kw{in} k \rightarrow \term \pator \vec{b}}
        {\kw{switch} \val \kw{in} \vec{b}}
}\rname{R-PatFail}
%
\end{mathpar}
%
\begin{mathpar}
%
\infer{
  \redto{\term_1}{\term'_1}
}{
  \redto{\kw{unpack} \term_1 \kw{as} \var \kw{in} \term_2}
        {\kw{unpack} \term'_1 \kw{as} \var \kw{in} \term_2}
}\rname{R-Unpack-1}
\\

\infer{
  \redto{\term_2}{\term'_2}
}{
  \redto{\kw{unpack} \val \kw{as} \var \kw{in} \term_2}
        {\kw{unpack} \val \kw{as} \var \kw{in} \term'_2}
}\rname{R-Unpack-2}

\infer{}{
  \redto{\kw{unpack} \val_1 \kw{as} \var \kw{in} \val_2}
        {\val_2\{\var \leftarrow \val\}}
}\rname{R-Unpack}
\\

\infer{
  \redto{\vec{\term}}{\vec{\term'}}
}{
  \redto{\app{prim}{\vec{\term}}}{\app{prim}{\vec{\term'}}}
}\rname{R-Prim}
\\

\end{mathpar}

\subsubsection{Réduction des primitives}

\begin{mathpar}
%
\infer{}{
  \redto{\kw{makeblock}_{k,\ty} \vec{v}}{\{k: \vec{v}\}}
}\rname{R-makeblock}

\infer{}{
  \redto{\kw{field}_i \{k: \vec{v}\}}{v_i}
}\rname{R-field}

\infer{}{
  \redto{\kw{shift}_z k}{z + k}
}\rname{R-shift}

\infer{}{
  \redto{\kw{tagof} k}{k}
}\rname{R-tagof-int}

\infer{}{
  \redto{\kw{tagof} \{k: \vec{v}\}}{k}
}\rname{R-tagof-block}

\infer{ k = z }
      { \redto{\kw{eq}_z k}{1} }
\rname{R-eq-1}

\infer{ k \neq z }
      { \redto{\kw{eq}_z k}{0} }
\rname{R-eq-0}

\infer{ k \le z }
      { \redto{\kw{lt}_z k}{1} }
\rname{R-less-1}

\infer{ k \nless z }
      { \redto{\kw{lt}_z k}{0} }
\rname{R-less-0}

\infer{}{
  \redto{\kw{isint} k}{1}
}\rname{R-isint-1}

\infer{}{
  \redto{\kw{isint} \{k: \vec{v}\}}{0}
}\rname{R-isint-0}

\infer{ k \notin [k_1,k_2] }
      { \redto{\kw{isout}_{[k_1,k_2]} k}{1} }
\rname{R-isout-1}

\infer{ k \in [k_1,k_2] }
      { \redto{\kw{isout}_{[k_1,k_2]} k}{0} }
\rname{R-isout-0}

\end{mathpar}

\subsection{Définition de la substitution}

\newcommand\subst{\{\var \leftarrow v\}}
\begin{align*}
           C \wedge C \subst \;&\Rightarrow\; C\subst \wedge C\subst        \\
    \term_1 = \term_2 \subst \;&\Rightarrow\; \term_1\subst = \term_2\subst \\
  \kw{tag} \var \in S \subst \;&\Rightarrow\; \top \\
  \kw{tag} y    \in S \subst \;&\Rightarrow\; \kw{tag} y \in S \\
                 \top \subst \;&\Rightarrow\; \top \\
                 \bot \subst \;&\Rightarrow\; \bot \\
\end{align*}

\begin{align*}
                            . \subst \;&\Rightarrow\; . \\
     \tyenvcons\tyenv{y}{\ty} \subst \;&\Rightarrow\; \tyenvcons\tyenv{y}{\ty \subst} \\
  \tyenvcons\tyenv{\alpha}{*} \subst \;&\Rightarrow\; \tyenvcons\tyenv{\alpha}{*} 
\end{align*}

\begin{align*}
                            . \subst \;&\Rightarrow\; . \\
     \tyenvcons\tyenv{y}{\ty} \subst \;&\Rightarrow\; \tyenvcons\tyenv{y}{\ty \subst} \\
  \tyenvcons\tyenv{\alpha}{*} \subst \;&\Rightarrow\; \tyenvcons\tyenv{\alpha}{*} 
\end{align*}

\begin{align*}
  \var
   \, \subst \;&\Rightarrow\; v
    \\
  y
   \, \subst \;&\Rightarrow\; y
    \\
  \term_1 \, \term_2
   \, \subst \;&\Rightarrow\; \term_1 \subst \, \term_2 \subst
    \\
  (\lambda \binding{y}{\ty} . \term)
   \, \subst \;&\Rightarrow\; \lambda \binding{y}{\ty \subst} . \term \subst
    \\
  (\Lambda \tyvar . \term)
   \, \subst \;&\Rightarrow\; \Lambda \tyvar . \term \subst
    \\
  \term \, \ty
   \, \subst \;&\Rightarrow\; \term \subst \, \ty \subst
    \\
  prim \, \vec{\term}
   \, \subst \;&\Rightarrow\; prim \, \vec{\term'} \; \text{où} \; \term'_i = \term_i \subst
    \\
  \kw{switch} \term \kw{in} \vec{b} : \ty
   \, \subst \;&\Rightarrow\; 
  \kw{switch} \term \subst \kw{in} \vec{b} \subst : \ty \subst 
    \\
  \kw{unpack} \term_1 \kw{as} y \kw{in} \term_2
   \, \subst \;&\Rightarrow\; 
  \kw{unpack} \term_1 \subst \kw{as} y \kw{in} \term_2 \subst
    \\
\end{align*}

\begin{align*}
  \ty_1 \rightarrow \ty_2
   \, \subst \;&\Rightarrow\; 
    \ty_1 \subst \rightarrow \ty_2 \subst
  \\
  \forall \tyvar. \ty
   \, \subst \;&\Rightarrow\; 
  \forall \tyvar. (\ty \subst)
  \\
  \{ \var \}_D
   \, \subst \;&\Rightarrow\; 
    D \, v
    &\text{où}\; \var = \{ x \}_D
  \\
  \kw{Tag}_z \var
   \, \subst \;&\Rightarrow\; 
    \kw{tag} D \, v
    &\text{où}\; \var = \{ x \}_D
  \\
  \{ n: \vec{\ty} \}
    \, \subst \;&\Rightarrow\; 
    \{ n: \vec{\ty'} \}
    &\text{où}\; \ty'_i = \ty_i \subst
  \\
  \epsilon \, \vec{\ty}
    \, \subst \;&\Rightarrow\; \epsilon \, \vec{\ty'}
    &\text{où}\; \ty'_i = \ty_i \subst
\end{align*}

\subsection{Propriétés du système de type}

\begin{lemma}[Inversion de la relation de typage]
\begin{mathpar}

\infer{
  \tycheck\tyenv\var\ty
}{
  \tyenvmem{\binding\var\ty}\tyenv
}

\infer{
  \tycheck{\csenv, \tyenv}{\lam{\binding\var{\ty_1}}{\term}}{\ty}
}{
  \ty = \tyarrow{\ty_1}{\ty_2} \\
  \tycheck{\csenv, \tyenvcons\tyenv\var{\ty_1}}{\term}{\ty_2}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term_1 \term_2}{\ty_2}
}{
  \tycheck{\csenv, \tyenv}{\term_1}{\tyarrow{\ty_1}{\ty_2}} \\
  \tycheck{\csenv, \tyenv}{\term_2}{\ty_1}
}

\infer{
  \tycheck{\csenv, \tyenv}{\Lambda \tyvar . \term }{\ty}
}{
  \ty = {\forall \tyvar.\, \ty'} \\
  \tycheck{\csenv, \tyenvcons{\tyenv}{\tyvar}{\tykind}}{\term}{\ty}
}

\infer{
  \tycheck{\csenv, \tyenv}{\term \, \ty_2}{\ty}
}{
  \ty =\ty_1 \{\tyvar \leftarrow \ty_2\} \\
  \tycheck{\csenv, \tyenv}{\term}{\forall \tyvar.\, \ty_1}
}

\infer{
  \tycheck{\csenv, \tyenv}{\kw{unpack} \term_1 \kw{as} \var \kw{in} \term_2}{\ty}
}{
  x \notin \kw{dom}(\tyenv) \\ x \notin \kw{FV}(\ty) \\
  \tycheck{\csenv, \tyenv}{\term_1}{D} \\
  \tycheck{\csenv, \tyenvcons{\tyenv}
                             {\var}{ \{ \var \}_D }}
          {\term_2}{\ty}
}

\infer{
  \tycheck{\csenv, \tyenv, x, D}{k \rightarrow \term \;|\; \vec{b}}{\ty}
}{
  k \in dom(D) \\
  \tycheck{\csenv \wedge \kw{tag} \var \in \{ k \} \wedge D k, \tyenv}{\term}{\ty} \\
  \tycheck{\csenv \wedge \kw{tag} \var \in \lnot \{ k \}, x, D, \tyenv}{\vec{b}}{\ty}
}

\infer{
  \tycheck{\csenv, \tyenv, x, D}{\_ \rightarrow \term}{\ty}
}{
  \tycheck{\csenv, \tyenv}{\term}{\ty}
}

\infer{
  \tycheck{\csenv, \tyenv, x, D}{\emptyset}{\ty}
}{
  \csenv, \tyenv \Vdash dom(D) \cap \kw{tag} x = \emptyset
}

\infer{
  \tycheck{\csenv, \tyenv}{\kw{switch} \term \kw{in} \vec{b}}{\ty}
}{
  \tycheck{\csenv, \tyenv}{\term}{\{ \var \}_D} \\
  \tycheck{\csenv, \tyenv, \var, D}{\vec{b}}{\ty}
}

\end{mathpar}

\begin{proof}
  Immédiate par inversion des règles de typage,
  le système est dirigé par la syntaxe.
\end{proof}
\end{lemma}

\pagebreak
\begin{lemma}[Préservation des types par substitution]
\begin{mathpar}
\infer{
  \tycheck{\csenv, \tyenvcons\tyenv\var{\ty'}}{\term}{\ty} \\
  \tycheck{\csenv, \tyenv}{\term'}{\ty'}
}{
  \tycheck{\csenv, \tyenv}{\term \{ \var \leftarrow \term' \}}{\ty}
}
\end{mathpar}

\begin{proof}
Par induction sur la dérivation du jugement
  $\tycheck{\csenv, \tyenvcons\tyenv\var{\ty'}}{\term}{\ty}$.
  
\rcase{T-Unpack} 
\begin{equation*}
\begin{aligned}
  & \term = \kw{unpack} \term_1 \kw{as} y \kw{in} \term_2 \\
  & y \notin dom(\tyenvcons\tyenv\var{\ty'}) \\
  & y \notin FV(\ty) \\
  & \tycheck{\csenv, \tyenvcons\tyenv\var{\ty'}}{\term_1}{\ty_1} \\
  & \tycheck{\csenv, \tyenvcons{\tyenvcons\tyenv\var{\ty'}}{y}{\ty_1}}{\term_2}{\ty}
\end{aligned}
\end{equation*}

Par hypothèse, $y \neq \var$.
L'hypothèse d'induction nous permet de déduire 
  $\tycheck{\csenv, \tyenvcons\tyenv{y}{\ty_1}}{\term_1}{\ty_1}$.
Par permutation de contexte, on montre
  $\tycheck{\csenv, \tyenvcons{\tyenvcons\tyenv{y}{\ty_1}}\var{\ty'}}{\term_2}{\ty}$.
En affaiblissement le contexte de la seconde hypothèse, on obtient
  $\tycheck{\csenv, \tyenvcons\tyenv{y}{\ty_1}}{\term'}{\ty'}$.
On peut alors appliquer l'hypothèse d'induction sur le terme $\ty_2$:
  $\tycheck{\csenv, \tyenvcons\tyenv{y}{\ty_1}}{\term_2\{\var \leftarrow \term'\}}{\ty'}$.
\\
On applique alors appliquer $\rref{T-Unpack}$ qui nous donne le résultat attendu.
  $\tycheck{\csenv, \tyenvcons\tyenv\var{\ty'}}
           {\kw{unpack} \term_1 \kw{as} y \kw{in} \term_2}{\ty}$.

\rcase{T-Switch}
\begin{equation*}
\begin{aligned}
  & \term = \kw{switch} \term_1 \kw{in} \vec{b} \\
  & \tycheck{\csenv, \tyenvcons\tyenv\var{\ty'}}{\term_1}{\{y\}_D} \\
  & \tycheck{\csenv, \tyenvcons\tyenv\var{\ty'}, y, D}{\vec{b}}{\ty}
\end{aligned}
\end{equation*}

Ici, deux cas se présentent : soit $y \neq \var$ et le cas est trivial, soit $y = \var$.
\todo{AHHHAH}.

\rcase{T-}

\end{proof}
\end{lemma}

